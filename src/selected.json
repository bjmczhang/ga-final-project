[{"id":3,"title":"Creating A Markdown Blog With React","author":"Benjamin Zhang","date":"14-08-2023","content":"\r\n> GA Final Project Presentation ——_Benjamin Zhang_\r\n\r\n## Project Intro\r\n\r\n- Markdown Blog built **without** any platform/headless CMS.\r\n- Pure logic for turning markdown files to data.\r\n- Visit live application: [**bjmblog.vercel.app** ](https://bjmblog.vercel.app/) & [**bjmblog-nextjs.vercel.app**](https://bjmblog-nextjs.vercel.app/)\r\n\r\n## Tech stack\r\n\r\n- **The First Version** (this presentation will primarily be based on this version)\r\n  - React\r\n  - react-router-dom\r\n  - markdown-to-jsx\r\n  - react-syntax-highlighter\r\n  - Vercel\r\n- **The Second Version**\r\n  - Next.js\r\n  - Tailwind CSS\r\n  - next-mdx-remote\r\n  - Vercel\r\n\r\n## App Structures & Features\r\n\r\n<img src=\"\\assets\\image-20230814223937565.png\" alt=\"image-20230814223937565\" style=\"zoom: 33%;\" />\r\n\r\n- **Layout**\r\n\r\n  - header with nav links\r\n  - footer\r\n\r\n- **Home Page**\r\n  - brief introduction about myself\r\n  - tech headlines (public api)\r\n  - selected posts\r\n- **Blog Page**\r\n  - posts list\r\n  - search with keywords\r\n  - filter by tags (multi-select)\r\n- **Post Page**\r\n  - rendering the markdown content to JSX (markdown-to-jsx)\r\n  - highlighting code blocks (syntaxHighlighter)\r\n- **About Page**\r\n  - personal info\r\n- **Not Found Page**\r\n\r\n## Challenges\r\n\r\n- **fetch markdown content**\r\n\r\n  👉 use Node.js modules 'path' and 'fs' to work with file paths and filesystem operations\r\n\r\n  ```jsx\r\n  const path = require(\"path\");\r\n  const fs = require(\"fs\").promises;\r\n\r\n  const dirPath = path.join(__dirname, \"../src/content\");\r\n  const dirPathPages = path.join(__dirname, \"../src/pages/content\");\r\n  ```\r\n\r\n  👉 extracting metadata from the Markdown files\r\n\r\n  ```jsx\r\n  const parseMetadata = ({ lines, metadataIndices }) => {\r\n    if (metadataIndices.length > 0) {\r\n      let metadata = lines.slice(metadataIndices[0] + 1, metadataIndices[1]);\r\n      let obj = {};\r\n      metadata.forEach((line) => {\r\n        obj[line.split(\":\")[0].trim()] = line.split(\":\")[1].trim();\r\n      });\r\n      return obj;\r\n    }\r\n  };\r\n  ```\r\n\r\n  👉 extracting content from the Markdown files\r\n\r\n  ```jsx\r\n  const parseContent = ({ lines, metadataIndices }) => {\r\n    if (metadataIndices.length > 0) {\r\n      let content = lines.slice(metadataIndices[1] + 1);\r\n      return content.join(\"\\n\");\r\n    }\r\n  };\r\n  ```\r\n\r\n  👉read data from markdown files, and then writes the collected information into a JSON file\r\n\r\n  ```jsx\r\n  const getPosts = async () => {\r\n    try {\r\n      const files = await fs.readdir(dirPath);\r\n      let postlist = await Promise.all(\r\n        files.map(async (file, i) => {\r\n          try {\r\n            const contents = await fs.readFile(`${dirPath}/${file}`, \"utf8\");\r\n            const lines = contents.split(\"\\n\");\r\n            const metadataIndices = lines.reduce(getMetadataIndices, []);\r\n            const metadata = parseMetadata({ lines, metadataIndices });\r\n            const content = parseContent({ lines, metadataIndices });\r\n\r\n            let post = {\r\n              id: i + 1,\r\n              title: metadata.title || \"No Title Given\",\r\n              author: metadata.author || \"No Author Given\",\r\n              date: metadata.date || \"No Date Given\",\r\n              tags: metadata.tags || \"No Tags Given\",\r\n              content: content || \"No Content Given\",\r\n            };\r\n            return post;\r\n          } catch (err) {\r\n            console.error(`Error processing file ${file}:`, err);\r\n            return null;\r\n          }\r\n        })\r\n      );\r\n\r\n      postlist = postlist.filter((post) => post !== null);\r\n\r\n      let data = JSON.stringify(postlist);\r\n      await fs.writeFile(\"src/posts.json\", data);\r\n    } catch (err) {\r\n      console.log(\"Failed to list contents of directory: \" + err);\r\n    }\r\n  };\r\n  ```\r\n\r\n  👉 after editing the markdown file, use command **'node public/main.js'** to execute the main.js file to update the json file\r\n\r\n  ```json\r\n  \"scripts\": {\r\n      \"server\": \"node public/main.js\"\r\n    },\r\n  ```\r\n\r\n- **rendering json objects to html**\r\n\r\n  👉 article/post pages\r\n\r\n  ```jsx\r\n  import { useParams } from \"react-router-dom\";\r\n  import postArticle from \"../posts.json\";\r\n  import Markdown from \"markdown-to-jsx\";\r\n\r\n  const params = useParams();\r\n  const article = postArticle.find((post) => post.title === params.slug);\r\n  ...\r\n  <Markdown>{article.content}</Markdown>\r\n  ```\r\n\r\n- **search, filter to get postlist and then sort them by date**\r\n\r\n  ```jsx\r\n  import postlist from \"../posts.json\";\r\n\r\n  const filteredPosts = postlist\r\n    .filter(\r\n      (post) =>\r\n        (post.title.toLowerCase().includes(searchQuery.toLowerCase()) ||\r\n          post.content.toLowerCase().includes(searchQuery.toLowerCase()) ||\r\n          post.author.toLowerCase().includes(searchQuery.toLowerCase()) ||\r\n          post.date.toLowerCase().includes(searchQuery.toLowerCase())) &&\r\n        postMatchesSelectedTags(post)\r\n    )\r\n    // Sort posts by date, from newest to oldest\r\n    .sort((a, b) => parseCustomDate(b.date) - parseCustomDate(a.date));\r\n  ```\r\n\r\n# Conclusion\r\n\r\nIn this presentation, I shared my journey of creating a Markdown blog with React. I'm grateful for your time. I'm glad that over the past couple of months, we've been learning React together. Enjoy coding, Thank you!\r\n","tags":"react,project","selected":"true"},{"id":4,"title":"Next.js Learning Notes","author":"Benjamin Zhang","date":"13-08-2023","content":"\r\n\r\n\r\n\r\n\r\n# Introduction\r\n\r\n\r\n\r\n## [What is Next.js?](https://nextjs.org/docs#what-is-nextjs)\r\n\r\n- A React framework for building full-stack web applications.\r\n- Abstracts and automatically configures tooling needed for React, like bundling, compiling, and more.\r\n\r\n\r\n\r\n## [Main Features](https://nextjs.org/docs#main-features)\r\n\r\n✅ Routing\t✅ Client-side Rendering (CSR)\t ✅ Server-side Rendering (SSR)\t✅ Simplified data fetching\t ✅ Extended fetch API\t✅ Support multiple styling methods\t ✅ Optimizations\t ✅ Support TypeScript\r\n\r\n\r\n\r\n# Installation\r\n\r\n```\r\nnpx create-next-app@latest\r\n```\r\n\r\n```js\r\nnpm run dev\r\n```\r\n\r\n\r\n\r\n# Project Structure\r\n\r\nhttps://nextjs.org/docs/getting-started/project-structure\r\n\r\n\r\n\r\n# Defining Routes\r\n\r\n\r\n\r\n### Creating Routes\r\n\r\nNext.js uses a file-system based router where **folders** are used to define routes.\r\n\r\n![Route segments to path segments](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Froute-segments-to-path-segments.png&w=3840&q=75&dpl=dpl_5nyE2qDUZA6TxAeNHaewdzrr4qMc)\r\n\r\n\r\n\r\n### Creating UI\r\n\r\n[Special file conventions](https://nextjs.org/docs/app/building-your-application/routing#file-conventions) are used to create UI for each route segment. The most common are [pages](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages) to show UI unique to a route, and [layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts) to show UI that is shared across multiple routes.\r\n\r\n\r\n\r\n# Pages and Layouts\r\n\r\n\r\n\r\n## [Pages](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages)\r\n\r\n- A page is UI that is **unique** to a route. \r\n\r\n- A page is always the [leaf](https://nextjs.org/docs/app/building-your-application/routing#terminology) of the [route subtree](https://nextjs.org/docs/app/building-your-application/routing#terminology).\r\n- ==.js==, ==.jsx==, or ==.tsx== file extensions can be used for Pages.\r\n- A `page.js` file is required to make a route segment publicly accessible.\r\n- Pages are [Server Components](https://nextjs.org/docs/getting-started/react-essentials) by default but can be set to a [Client Component](https://nextjs.org/docs/getting-started/react-essentials#client-components).\r\n- Pages can fetch data. View the [Data Fetching](https://nextjs.org/docs/app/building-your-application/data-fetching) section for more information.\r\n\r\n\r\n\r\n## [Layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts)\r\n\r\n- A layout is UI that is **shared** between multiple pages.\r\n- Layouts can also be [nested](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#nesting-layouts)\r\n- The top-most layout is called the [Root Layout](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required). This **required** layout is shared across all pages in an application. Root layouts must contain ==html== and ==body== tags.\r\n- Layouts in a route are **nested** by default. Each parent layout wraps child layouts below it using the React ==children== prop.\r\n- You can use [Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups) to opt specific route segments in and out of shared layouts.\r\n- Layouts are [Server Components](https://nextjs.org/docs/getting-started/react-essentials) by default but can be set to a [Client Component](https://nextjs.org/docs/getting-started/react-essentials#client-components).\r\n- A ==layout.js== and ==page.js== file can be defined in the same folder. The layout will wrap the page.\r\n\r\n\r\n\r\n### [Root Layout (Required)](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required)\r\n\r\n- The root layout is defined at the top level of the ==app== directory and applies to all routes.\r\n- The root layout must define ==<html>== and ==<body>==\r\n\r\n\r\n\r\n# Linking and Navigating\r\n\r\nThere are two ways to navigate between routes in Next.js:\r\n\r\n- Using the [<Link>Component](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#link-component)\r\n- Using the [==useRouter== Hook](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#userouter-hook)\r\n\r\n\r\n\r\n## [<Link> Component](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#link-component)\r\n\r\n```\r\nimport Link from 'next/link'\r\n \r\nexport default function Page() {\r\n  return <Link href=\"/dashboard\">Dashboard</Link>\r\n}\r\n```\r\n\r\n#### [Linking to Dynamic Segments](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#linking-to-dynamic-segments)\r\n\r\n```\r\nimport Link from 'next/link'\r\n \r\nexport default function PostList({ posts }) {\r\n  return (\r\n    <ul>\r\n      {posts.map((post) => (\r\n        <li key={post.id}>\r\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )\r\n}\r\n```\r\n\r\n#### [Checking Active Links](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#checking-active-links)\r\n\r\nYou can use [==usePathname()==](https://nextjs.org/docs/app/api-reference/functions/use-pathname) to determine if a link is active. \r\n\r\n```\r\n'use client'\r\n \r\nimport { usePathname } from 'next/navigation'\r\nimport Link from 'next/link'\r\n \r\nexport function Navigation({ navLinks }) {\r\n  const pathname = usePathname()\r\n \r\n  return (\r\n    <>\r\n      {navLinks.map((link) => {\r\n        const isActive = pathname === link.href\r\n \r\n        return (\r\n          <Link\r\n            className={isActive ? 'text-blue' : 'text-black'}\r\n            href={link.href}\r\n            key={link.name}\r\n          >\r\n            {link.name}\r\n          </Link>\r\n        )\r\n      })}\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n#### [Scrolling to an `id`](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#scrolling-to-an-id)\r\n\r\n```\r\n<Link href=\"/dashboard#settings\">Settings</Link>\r\n \r\n// Output\r\n<a href=\"/dashboard#settings\">Settings</a>\r\n```\r\n\r\n## [`useRouter()` Hook](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#userouter-hook)\r\n\r\nThe ==useRouter== hook allows you to programmatically change routes.\r\n\r\n\r\n\r\n# Route Groups\r\n\r\nYou can mark a folder as a **Route Group** to prevent the folder from being included in the route's URL path.\r\n\r\nA route group can be created by wrapping a folder's name in parenthesis: ==(folderName)==\r\n\r\n![Organizing Routes with Route Groups](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Froute-group-organisation.png&w=3840&q=75&dpl=dpl_4wceNrAn3myUmyVmW3g6XDEvYfP8)\r\n\r\nTo create multiple [root layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#root-layout-required), remove the top-level ==layout.js== file, and add a ==layout.js== file inside each route groups. This is useful for partitioning an application into sections that have a completely different UI or experience. The ==<html>== and ==<body>== tags need to be added to each root layout.\r\n\r\n![Route Groups with Multiple Root Layouts](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Froute-group-multiple-root-layouts.png&w=3840&q=75&dpl=dpl_4wceNrAn3myUmyVmW3g6XDEvYfP8)\r\n\r\n\r\n\r\n# Dynamic Routes\r\n\r\n## [Convention](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#convention)\r\n\r\nA Dynamic Segment can be created by wrapping a folder's name in square brackets: ==[folderName]==. For example, ==[id]== or ==[slug]==.\r\n\r\n## [Catch-all Segments](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)\r\n\r\nDynamic Segments can be extended to **catch-all** subsequent segments by adding an ellipsis inside the brackets ==[...folderName]==.\r\n\r\n## [Optional Catch-all Segments](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments)\r\n\r\nCatch-all Segments can be made **optional** by including the parameter in double square brackets: ==[[...folderName]]==.\r\n\r\nThe difference between **catch-all** and **optional catch-all** segments is that with optional, the route without the parameter is also matched.\r\n\r\n```\r\n// app\\blog\\[slug]\\page.tsx\r\nconst Page = ({ params }: { params: { slug: string } }) => {\r\n  return <h1>slug page @@@ {params.slug}</h1>;\r\n};\r\n\r\nexport default Page;\r\n```\r\n\r\n\r\n\r\n# Loading UI and Streaming\r\n\r\nThe special file ==loading.js== helps you create meaningful Loading UI with [React Suspense](https://react.dev/reference/react/Suspense). \r\n\r\n## [Instant Loading States](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)\r\n\r\nAn instant loading state is fallback UI that is shown immediately upon navigation. \r\n\r\nCreate a loading state by adding a `loading.js` file inside a folder.\r\n\r\n![loading.js special file](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Floading-special-file.png&w=3840&q=75&dpl=dpl_46ncsoiUzpeReYYC8yec1ZDMzFik)\r\n\r\nIn the same folder, ==loading.js== will be nested inside ==layout.js==. It will automatically wrap the ==page.js== file and any children below in a ==<Suspense>== boundary.\r\n\r\n![loading.js overview](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Floading-overview.png&w=3840&q=75&dpl=dpl_46ncsoiUzpeReYYC8yec1ZDMzFik)\r\n","tags":"nextjs","selected":"true"},{"id":5,"title":"React Hooks and Their Rules","author":"No Author Given","date":"18-06-2023","content":"\r\n\r\n\r\n## What Are React Hooks?\r\n\r\n👉 Special built-in functions that allow us to \"hook\" into React internals:\r\n\r\n- Creating and accessing state from Fiber tree\r\n- Registering side effects in Fiber tree\r\n- Manual DOM selections\r\n- Many more...\r\n\r\n> The Fiber tree is somewhere deep inside React, and usually not accessible to us. But using the useState or the useEffect hook, we can essentially hook into that internal mechanism.\r\n\r\n👉 Always start with \"use\" (useState, useEffect, etc.)\r\n\r\n👉 Enable easy reusing of non-visual logic: We can compose multiple hooks into our own custom hooks\r\n\r\n👉 Give function components the ability to own state and run side effects at different points (before v16.8 only available in class components)\r\n\r\n\r\n\r\n## Overview of All Built-in Hooks\r\n\r\n| MOST USED |     LESS USED |      ONLY FOR LIBRARIES |\r\n| ---- | ---- | ----|\r\n| ✅ useState | ➡️ useRef | ❌ useSyncExternalStore |\r\n| ✅ useEffect | ➡️ useCallback | ❌ useInsertonEffect |\r\n| ➡️ useReducer | ➡️ useMemo |\t\t|\r\n| ➡️ useContext | ➡️ useTransition |\t\t|\r\n|      | ➡️ useDeferredValue |\t\t|\r\n|      | ❌ useLayoutEffect |\t\t|\r\n|      | ❌ useDebugValue |\t\t|\r\n|      | ❌ useImperativeHandle |\t\t|\r\n|      | ❌ useId |\t\t|\r\n\r\n\r\n\r\n## The Rules of Hooks\r\n\r\n#### 1. Only call hooks at the top level\r\n\r\n​\t👉 Do **NOT** call hooks inside **conditionals, loops, nested functions**, or after an **early return**\r\n\r\n​\t👉 This is necessary to ensure that hooks are always called in the **same order** (hooks rely on this)\r\n\r\n#### 2. Only call hooks from React functions\r\n\r\n​\t👉 Only call hooks inside a **function component** or a **custom hook**\r\n\r\n> These rules are automatically enforced by React's ESLint rules\r\n\r\n\r\n\r\n![image-20230804215448826](/assets/image-20230804215448826.png)","tags":"react","selected":"true"},{"id":6,"title":"Summary of JSON Learning","author":"No Author Given","date":"16-06-2023","content":"\r\n\r\n\r\nJSON stands for JavaScript Object Notation, and it is a data interchange format.\r\n\r\n> Before JSON came along, XML was used to transmit data because it is a text-based format suitable for data exchange over the internet. However, XML became complex when combined with specifications like DTD, XSD, XPath, and XSLT, making it challenging for developers to work with. In 2002, Douglas Crockford, a senior architect at Yahoo, came up with JSON, a super-lightweight data interchange format, to rescue software engineers from the complexities of XML imposed by giant software companies.\r\n\r\nJSON is actually a subset of JavaScript. It supports a few simple data types:\r\n\r\n- ==number==: same as JavaScript's ==number==.\r\n- ==boolean==: equivalent to ==true== or ==false== in JavaScript.\r\n- ==string==: similar to JavaScript's ==string==.\r\n- ==null==: equivalent to ==null== in JavaScript.\r\n- ==array==: same as JavaScript's ==Array==, represented by ==[]==.\r\n- ==object==: similar to JavaScript's =={ ... }==.\r\n\r\nJSON also enforces that character encoding must be UTF-8 and strings must be enclosed in double quotes. Object keys are also required to be enclosed in double quotes.\r\n\r\nJSON quickly gained popularity in the web world and became an ECMA standard. Almost all programming languages have libraries for parsing JSON, and in JavaScript, JSON is natively supported, making it convenient to use.\r\n\r\nTo serialize any JavaScript object into JSON, you need to convert the object into a JSON-formatted string, allowing it to be transmitted over the network. To deserialize a JSON string into a JavaScript object, you simply parse the JSON string.\r\n\r\n### Serialization\r\n\r\nLet's start by serializing the object `xiaoming` into a JSON-formatted string:\r\n\r\n```js\r\n'use strict';\r\n\r\nvar xiaoming = {\r\n    name: '小明',\r\n    age: 14,\r\n    gender: true,\r\n    height: 1.65,\r\n    grade: null,\r\n    'middle-school': '\\\"W3C\\\" Middle School',\r\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\r\n};\r\n```\r\n\r\nTo format the output, you can add parameters to control indentation:\r\n\r\n```js\r\nJSON.stringify(xiaoming, null, '  ');\r\n```\r\n\r\nThe result will be:\r\n\r\n```js\r\n{\r\n  \"name\": \"小明\",\r\n  \"age\": 14,\r\n  \"gender\": true,\r\n  \"height\": 1.65,\r\n  \"grade\": null,\r\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\r\n  \"skills\": [\r\n    \"JavaScript\",\r\n    \"Java\",\r\n    \"Python\",\r\n    \"Lisp\"\r\n  ]\r\n}\r\n```\r\n\r\nYou can also provide an array as the second argument to filter specific properties:\r\n\r\n```js\r\nJSON.stringify(xiaoming, ['name', 'skills'], '  ');\r\n```\r\n\r\nThe result will be:\r\n\r\n```js\r\n{\r\n  \"name\": \"小明\",\r\n  \"skills\": [\r\n    \"JavaScript\",\r\n    \"Java\",\r\n    \"Python\",\r\n    \"Lisp\"\r\n  ]\r\n}\r\n```\r\n\r\nTo have more precise control over the serialization process, you can pass a function as the second argument, which will process each key-value pair in the object:\r\n\r\n```js\r\nfunction convert(key, value) {\r\n    if (typeof value === 'string') {\r\n        return value.toUpperCase();\r\n    }\r\n    return value;\r\n}\r\n\r\nJSON.stringify(xiaoming, convert, '  ');\r\n```\r\n\r\nThe result will be:\r\n\r\n```js\r\n{\r\n  \"name\": \"小明\",\r\n  \"age\": 14,\r\n  \"gender\": true,\r\n  \"height\": 1.65,\r\n  \"grade\": null,\r\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\r\n  \"skills\": [\r\n    \"JAVASCRIPT\",\r\n    \"JAVA\",\r\n    \"PYTHON\",\r\n    \"LISP\"\r\n  ]\r\n}\r\n```\r\n\r\nIf you want to precisely control how `xiaoming` is serialized, you can define a `toJSON()` method on `xiaoming` to directly return the data that should be serialized as JSON:\r\n\r\n```js\r\nvar xiaoming = {\r\n    name: '小明',\r\n    age: 14,\r\n    gender: true,\r\n    height: 1.65,\r\n    grade: null,\r\n    'middle-school': '\\\"W3C\\\" Middle School',\r\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],\r\n    toJSON: function () {\r\n        return { // Only output name and age, and change the keys:\r\n            'Name': this.name,\r\n            'Age': this.age\r\n        };\r\n    }\r\n};\r\n\r\nJSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}'\r\n```\r\n\r\n### Deserialization\r\n\r\nTo parse a JSON-formatted string and convert it back to a JavaScript object, you can use `JSON.parse()`:\r\n\r\n```js\r\nJSON.parse('[1,2,3,true]'); // [1, 2, 3, true]\r\nJSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}\r\nJSON.parse('true'); // true\r\nJSON.parse('123.45'); // 123.45\r\n```\r\n\r\n`JSON.parse()` also accepts a function as the second argument, which can be used to transform the parsed properties:\r\n\r\n```js\r\n'use strict';\r\n\r\nvar obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) {\r\n    if (key === 'name') {\r\n        return value + '同学';\r\n    }\r\n    return value;\r\n});\r\nconsole.log(JSON.stringify(obj)); // {name: '小明同学', age: 14}\r\n```\r\n\r\nUsing JSON in JavaScript is that simple!","tags":"json,javascript","selected":"true"}]